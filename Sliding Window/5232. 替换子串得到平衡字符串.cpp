/*
    问题描述：
        有一个只含有 'Q', 'W', 'E', 'R' 四种字符，且长度为 n 的字符串。
        假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。

        给你一个这样的字符串 s，请通过「替换子串」的方式，使原字符串 s 变成一个「平衡字符串」。
        你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。
        请返回待替换子串的最小可能长度。
        如果原字符串自身就是一个平衡字符串，则返回 0。

        示例 1：

        输入：s = "QWER"
        输出：0
        解释：s 已经是平衡的了。
        示例 2：

        输入：s = "QQWE"
        输出：1
        解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 "RQWE" (或 "QRWE") 是平衡的。
        示例 3：

        输入：s = "QQQW"
        输出：2
        解释：我们可以把前面的 "QQ" 替换成 "ER"。 
        示例 4：

        输入：s = "QQQQ"
        输出：3
        解释：我们可以替换后 3 个 'Q'，使 s = "QWER"。
         

        提示：

        1 <= s.length <= 10^5
        s.length 是 4 的倍数
        s 中只含有 'Q', 'W', 'E', 'R' 四种字符

    问题分析：
        简直是滑动窗口的超级好的题啊！！！

        为了这题，专门开了一个文件夹！！

        本题要求，更替一段区间，然后满足每个字符出现的次数小于n/4

        那么就维护一个区间，

        如果删掉这个区间里的字符以后， 每个字符都小于等于n/4

        那么这个区间就可以更替，

        我们的目标是找到最小的这样的区间，用双指针来做。

        l代表区间的左边，r代表区间的右边，

        只要有一个字符出现次数超过了n/4， 那么r就右移，并将加进来的字符出现次数减去1 （因为区间里的字符是要删除的
        当满足条件以后， 就开始移动l指针， 同理向右移动， 将移出去的字符出现次数加1， 直到不满足条件，
        这个时候， 计算区间大小，并更新res

        我们取最小的那段区间！
*/

class Solution {
public:
    int balancedString(string s) {
        int res = INT_MAX;
        int l = 0 , r = 0;
        unordered_map<int,int> cnt;
        for ( auto c:s ) ++cnt[c];
        int d = s.size()/4;
        while( r<s.size() ){
            while( r<s.size() && !( cnt['Q']<=d && cnt['W']<=d && cnt['E']<=d && cnt['R']<=d ) ){
                cnt[s[r]]--;
                ++r;
            }
            while( l<s.size() && ( cnt['Q']<=d && cnt['W']<=d && cnt['E']<=d && cnt['R']<=d ) ){
                res = min( r-l, res );
                ++cnt[s[l]];
                ++l;
            }
        }
        return res;
    }
};