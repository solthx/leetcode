/*
    问题描述：
        数组每一个元素代表可走步数，返回能否从0出发抵达最后一个元素
    
    问题分析：
        因为越靠后的元素，离最后一个元素的距离越近，越是可以一次抵达，
        所以选择从后向前遍历。
        而假如n-1可以抵达到n，那么可以更新目标到n-1就行了，
        这样的话，会有一些原本是要间接抵达终点的情况又变成了直接抵达终点的情况，
        例如n-4最多到n-1，然后才能到n，这样需要两次移动，但如果终点变成了n-1，那么
        n-4就又可以一次抵达终点。
        所以，我们要不停的更新终点位置。
        
        总结下就是：
            1. 从后向前遍历
            2. 更新终点位置
        
        最后就是，只要 index + nums[index] > 终点位置 ， 
        那么index就是可以抵达终点的， 这时候就可以把终点更新成index
        
        再多说两句就是，因为是从后向前遍历的，且之所以能够不断更新终点的一个最主要的
        原因就是，如果i能够抵达终点，那么j如果能够抵达终点则一定可以抵达i, 
        j如果能抵达i那么也一定可以抵达终点。
        
*/

class Solution {
public:
    bool canJump(vector<int>& nums) {
        int last = nums.size()-1; //一开始终点是最后一个元素
        for ( int j=nums.size()-1; j>=0; --j ){
            if (j+nums[j]>=last) //当前位置可以抵达终点，那么当前位置就可以更新成终点 
                last = j;
        }
        return last<=0;
    }

};