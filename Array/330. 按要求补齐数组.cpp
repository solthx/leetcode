/*
	题目描述：
		给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

		示例 1:
		输入: nums = [1,3], n = 6
		输出: 1 
		解释:
			根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
			现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
			其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
			所以我们最少需要添加一个数字。
		
		示例 2:
		输入: nums = [1,5,10], n = 20
		输出: 2
		解释: 我们需要添加 [2, 4]。
		
	题目分析：
		遍历数组的同时，维护两个变量cur_n和cnt，cur_n表示当前序列可以用和的形式来表示区间[1,cur_n-1]的任意值
		然后，当cur_n大于n的时候，当前的序列就满足了要求，cnt表示要加几个数。
		
		遍历nums:
			1. nums[i]<=cur_n: 
				因为nums[0]~nums[i-1]可以用和的形式表示区间[1,cur_n-1],
				所以若nums[i]<=cur_n,  那么当前序列一定也可以表示nums[i]，
				这时，前i个元素就可以用和的形式来表示nums[i]+cur_n-1,
				这时区间变成了[1,nums[i]+cur_n-1], 此时的cur_n就变成了cur_n+nums[i]
				所以这里做的操作就是：
				cur_n += nums[i]
				i++ 
			
			2. nums[i]>cur_n:
				这个时候，因为前i-1个元素只能表示1~cur_n， 所以这里就需要再加一个数了，
				没错，加的这个数就是当前的i-1个元素中所能表示的最大数，就是cur_n
				道理和"<="的情况相同， 不过是加的不是num[i]而是cur_n， 并且这个cur_n本身是
				不存在于当前数组的，是新引入的，所以cnt++，因为并不是存在于当前数组，所以
				nums[i]依旧没被处理，所以i还是不变，
				所以这里的操作就是：
				cnt++ 
				cur_n += cur_n (或 cur_n *= 2 )
*/
class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        long cur_n=1;
        int i=0,cnt=0;
        while( cur_n<=(long)n  ){
            if ( i<nums.size() && nums[i]<=cur_n )
                cur_n += nums[i++];
            else{
                cnt++;
                cur_n *= 2;
            }
        }
        return cnt;
    }
};
