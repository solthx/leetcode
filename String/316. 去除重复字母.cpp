/*
	题目描述：
		给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

		示例 1:

		输入: "bcabc"
		输出: "abc"
		示例 2:

		输入: "cbacdcbc"
		输出: "acdb"

	题目分析：
		先分析题目的要求:
			1. 不重复字母
			2. 最小字典序 
			
		遍历字符串，选取正确位置的字符把它放到结果序列中的正确的位置.
		(例如bcabc) 就是把"dbcabc"中的"dabc"放到结果字符串里
		
		对于遍历的每一个字符s[i]:
			1.如果s[i]已经出现在结果字符序列里了，那么就不需要放了
			2.如果s[i]没出现过在结果字符序列里，则需要把这个字符就位:
				因为要求字典序最小，这里就用到了贪心，
				从后向前遍历结果字符序列，把所有"比s[i]大且在位置i的后面还出现过的字符"给pop出去(说明后面还有更好的)，
				然后再把当前的字符push进去
			最终得到的结果序列就是字典序最小的乎重复集合.

		举例:
			1. 依次扫描字符。
			2. 发现是b，放到结果里。 > b
			3. 发现是c，回头看看已有的b，虽然后面也有b，但是b很小，没必要用后面的。 >bc
			4. 继续扫描a，发现前面的bc都比a大，而且后面还有bc，那么bc清理掉。放入a。简单理解则是：后面有更优的（字母序小） >a
			5. 继续扫描b，发现里面还没放入,而且前面的都小；>ab
			6. 继续扫描c，发现没有，而且前面的都是小的，直接放入; >abc
			7. 结束。	
				
		伪代码:
			1. 扫描字符串，结果串置空；
			2. 如果当前字符用过了，扫描下一个；
			3. 如果当前字符串没用过，则判定结果串的字符串是否存在需要优化的字符。优化的条件：里面有大于当前字符的，并且后面存在重复的，也就是用后面的即可。
			4. 重复2,3步骤直到无字符串可以扫描。
			5. 按先进先出的原则输出结果串。
*/

class Solution {
public:
    string removeDuplicateLetters(string s) {
        char stack[s.size()+1];
        int count[26]={0},top=-1;
        bool visited[26]={false};
        string res = "";
        for ( auto e:s )
            count[e-'a']++;
        for ( int i=0; i<s.size(); ++i ){
            count[s[i]-'a']--;
            if ( visited[s[i]-'a'] ) continue;
            while( top>=0 && stack[top]>s[i] && count[stack[top]-'a']>0 ){
                visited[stack[top]-'a'] = false;
                --top;
            }
            stack[++top] = s[i];
            visited[s[i]-'a'] = true;
        }
        for ( int i=0; i<=top; ++i )
            res += stack[i];
        return res;
    }
};