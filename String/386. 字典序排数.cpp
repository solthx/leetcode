/*
    问题分析:
        给定一个整数 n, 返回从 1 到 n 的字典顺序。
        例如，
        给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。
        请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。

    问题分析:
        对于数字的字典序，可以抽象成一个十叉树
        
                      1                   2    3  ...
         /  /  /  /  / \  \  \  \ \     
        /  /  /  /  /   \  \  \  \ \
       10 11 12 13 14   15 16 17 18 19

       而数字的字典序，就是这个十叉树的前序遍历。

       知道了这个以后，就可以按照规则来一个一个放入元素到res里

 */

class Solution1 {
public:
    vector<int> lexicalOrder(int n) {
        int cur=1;
        vector<int> res(n);
        res[0] = 1;
        for ( int i=1; i<n; ++i ){
            // 理解成十叉树的前序遍历
            if ( cur*10<=n ) //向左走 
                cur*=10;
            else if ( cur%10==9 ){
                // 最后一个叶子，返回
                //if ( cur+1>n ) break;
                cur = (cur+1);
                while( cur%10==0 )
                    cur /= 10; //不知道要返回几层
            }else{
                // 其他情况
                if ( cur+1<=n ) cur++;
                else{
                    cur=cur/10+1; // cur/10的叶子不足十个， 返回到父亲节点的下一个节点， 父亲节点是cur/10
                    // 如果父亲节点已经是最后一个节点了，那么下一个节点还要再返回
                    while( cur%10==0 )
                        cur/=10;
                }
            }
            res[i] = cur;
        }
        return res;
    }
};