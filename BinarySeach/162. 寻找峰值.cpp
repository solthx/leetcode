/*
    问题描述:
        峰值元素是指其值大于左右相邻值的元素。
        给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。
        数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。
        你可以假设 nums[-1] = nums[n] = -∞。

        示例 1:

            输入: nums = [1,2,3,1]
            输出: 2
            解释: 3 是峰值元素，你的函数应该返回其索引 2。
        示例 2:

            输入: nums = [1,2,1,3,5,6,4]
            输出: 1 或 5 
            解释: 你的函数可以返回索引 1，其峰值元素为 2；
                 或者返回索引 5， 其峰值元素为 6。
        说明:

            你的解法应该是 O(logN) 时间复杂度的。
        
    问题分析:
        一般的二分查找，只是单纯的比较中间值和两端值的大小，
        推广一下也就是，根据中间值的状态，来缩小区间(决定是取左区间还是右区间)
        因此，本题虽然是二分查找，但在判断中间状态时，
        不再是将它和两端元素进行比较，
        而是看中间元素处于上坡状态还是下坡状态,
        如果处于上坡，那么峰值一定在右区间，
        如果处于下坡，那么峰值一定在左区间.
        当区间被缩成一点的时候，这个点就是峰值
*/

class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int l = 0, mid;
        int r = nums.size()-1;
        while( l<r ){
            mid = (l+r)/2;
            if ( mid>=nums.size() || nums[mid+1]<nums[mid] )
                r = mid;
            else l = mid+1;
        }
        return l;
    }
};