/*
    问题描述:
        给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。

        每一步，你可以从下标 i 跳到下标：

        i + 1 满足：i + 1 < arr.length
        i - 1 满足：i - 1 >= 0
        j 满足：arr[i] == arr[j] 且 i != j
        请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。

        注意：任何时候你都不能跳到数组外面。

        

        示例 1：

        输入：arr = [100,-23,-23,404,100,23,23,23,3,404]
        输出：3
        解释：那你需要跳跃 3 次，下标依次为 0 --> 4 --> 3 --> 9 。下标 9 为数组的最后一个元素的下标。
        示例 2：

        输入：arr = [7]
        输出：0
        解释：一开始就在最后一个元素处，所以你不需要跳跃。
        示例 3：

        输入：arr = [7,6,9,6,9,6,9,7]
        输出：1
        解释：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。
        示例 4：

        输入：arr = [6,1,9]
        输出：2
        示例 5：

        输入：arr = [11,22,7,7,7,7,7,7,7,22,13]
        输出：3

    问题分析:
        通过这题收获颇多。。下面来一一道来..

        因为跳跃游戏V的影响，看到这种题型条件反射的就开始写dfs+记忆化了..
        dp[i]记录i跳到最后一个位置的最小步数，然后自底向上的更新.. 看起来是那么的常规..

        但wa了一发之后在发现.. 如果使用记忆化的话，会出现环的问题.. 
        就是说，dp[i]想得到最优解，需要先求出dp[j]，而dp[j]想得到最优解，需要先求出dp[i]。。

        而记忆化搜索应该是处理无环的关系依赖.. 就像跳跃游戏V里的那样，因为高度的限制关系，其依赖次序是不存在环的，所以可以用记忆化..
        ps: 与染色不同的是，对于路径染色的问题(例如 #565. 数组嵌套), 虽然有些情况存在依赖环，
        但那题是因为这种依赖是线性的环，且一旦出现环，一定是不存在的情况..  比较特殊.. 所以像用memo[] = -1来记录来标记已经访问过的来进行记忆化时，
        一定要想清楚：
            1. 是否这种出现环的情况是唯一的
            2. 是否一旦出现环就能确定某个结果(例如不存在之类的)
        
        因此，由于多依赖且存在环的情况，本题不能用记忆化来做..

        如果不能用记忆化的话，像这种关系转移层次很明显的，求最少步数的问题，妥妥的就bfs了..(然后又犯了另一个蠢)

        快速的撸了一个bfs，尽管用了数组倒排，但还是超时了.. 

        在分析复杂度的时候想，每个数组加个vis标记，复杂度应该是O(N)才对啊.. 
        后来发现，在从一个状态移动到下一个状态的时候:
            1. 移动到左右位置 O(1)
            2. 移动到同值的位置O(K) K为同值的个数..
        发现，在极限情况，同值的个数可能为N， 这个时候，复杂度就变成了N^2。。

        但是，当扫描过一次同值位置的时候，对于这个值来说， 下次就已经没必要再扫描一次了。。
        所以，当扫描玩一次这个值以后，就从倒排数组里把这个值删除.. 
        加上这个优化就AC了.. 复杂度为O（N） 也是本题的最优解.

        本题得到的收获:
            1. 当出现 一对多的依赖的情况 且存在环的情况，本题不能用记忆化来做
            2. 在进行BFS，分析复杂度的时候， 要考虑到状态转移的复杂度！！！（本次就是忽视了O(K)退化到O(N)这一情况)
*/

class Solution {
public:
    unordered_map<int, vector<int>> mp;
    int minJumps(vector<int>& arr) {
        if ( arr.size()==1 ) return 0;
        for ( int i=0; i<arr.size(); ++i ){
            mp[arr[i]].push_back(i);
        }
        int res=0, vis[60000]={false};
        queue<int> q;
        
        q.push(0); 
        
        vis[0] = true;
        
        while(q.size()>0){
            for ( int j=q.size(); j>0; --j ){
                int cur = q.front(); q.pop();
                if ( cur+1==arr.size() ) return res;
                // 状态传递
                // 同值跳
                for ( auto&d:mp[arr[cur]] ){
                    if ( d!=cur && !vis[d] ){
                        vis[d]=true;
                        q.push(d);
                    }
                }
                // 删除这个值
                mp.erase(arr[cur]);
                
                // 左右跳
                if ( cur+1<arr.size() && !vis[cur+1]  ){
                    vis[cur+1]=true;
                    q.push(cur+1);
                }
                if ( cur-1>=0 && !vis[cur-1]  ){
                    vis[cur-1]=true;
                    q.push(cur-1);
                }
            }
            ++res;
        }
        return -1;
    }
};