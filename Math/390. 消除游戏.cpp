/*
    问题描述：
        给定一个从1 到 n 排序的整数列表。
        首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。
        第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。
        我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
        返回长度为 n 的列表中，最后剩下的数字。

        示例：

        输入:
        n = 9,
        1 2 3 4 5 6 7 8 9
        2 4 6 8
        2 6
        6

        输出:
        6

    问题分析：
        1. 难点一是想到把  2 4 6 8 转换成 2* 1 2 3 4然后递归的做
        2. 难点二是分奇偶讨论（还是找规律
        3. 然后就是找规律了，推递推了

        kind为true的时候，是从左向右扫描，false是从右向左
        因为保证向右扫描的时候，n都是连续的（1，2，3，4，5，...，n
        所以向右扫描的时候，删去数字后，
        一定是 2 4 6 8 。。, 
        一定可以分成 2* func(n/2)

        而向左扫描的时候，奇数情况正常，偶数情况会出现[1,3,5,7,9,..]
        这里的处理办法就是，给每一个数先加一，凑成[2,4,6,8,..,]
        再分成2*[1,2,3,4..] 因为我们最终要的只是一个数，所以实际上只是加了1
        所以再后面再-1就行。
 */

 class Solution {
public:
    // 难点一是想到把  2 4 6 8 转换成 2* 1 2 3 4然后递归的做
    // 难点二是分奇偶
    // 然后就是找规律了，推递推了
    int lastRemaining(int n) {
        return helper( n, true );
    }
    
    int helper( int n, bool kind ){
        if ( n==1 ) return 1;
        if ( kind ){
            return 2 * helper( n/2 , false);
        }else{
            if ( n%2==1 )
                return 2* helper( n/2 , true);
            else return 2*helper(n/2, true)-1;
        }
    }
    
};

