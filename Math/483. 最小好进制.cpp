/*
    问题描述:
        对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。
        以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。
        示例 1：

        输入："13"
        输出："3"
        解释：13 的 3 进制是 111。
        示例 2：

        输入："4681"
        输出："8"
        解释：4681 的 8 进制是 11111。
        示例 3：

        输入："1000000000000000000"
        输出："999999999999999999"
        解释：1000000000000000000 的 999999999999999999 进制是 11。
         

        提示：

        n的取值范围是 [3, 10^18]。
        输入总是有效且没有前导 0。

    问题分析:
        这题做起来 让我有种在做高考数学题一样的感觉。。

        数学题，先建模！

        本题就是要求出 k满足:
            1 + k + ... + k^(m-1) = n
        假设等式左边有m项。

        等比数列的求和公式得到：
            ( k^m - 1 ) / (k-1) = n
        
        进一步化简得到:
            k^m = n*k-(n-1)
        两边加个log_k ( 为了方便写， 后面的log就默认以k为底

        m = log( n*k-(n-1) ) < log(n*k) = logn +1
        
        即 m<ceil(logn)+1

        因为m为项数，最小为2项
        于是得到了m的取值范围为 [2,ceil(logn)+1]

        得到m-1<logn
        两边作为k的指数，得到

        k^(m-1) < n 
        k< n^(1/(m-1))

        k是进制数，最少为2
        所以得到了k的取值范围为[2, ceil(n^(1/(m-1)))]

        因此 k∈[2, ceil(n^(1/(m-1)))]
            m∈[2,ceil(logn)+1]

    于是，可以枚举k和m的所有情况，来得到满足:
        1 + k + ... + k^(m-1) = n 
    的m和k

    因为问题问的是最小的好进制，因此k越小越好，即m越大越好。

    所以我们从大往小的来扫描m 的情况：

    for m : ceil(logn)+1 to 2
        在找k的时候，可以用二分来找 (这题用c++暴力来找的话。。会超出数据能表示的范围)
        l=2, r=ceil(n^(1/(m-1)))
        while l<r:
            确定mid，并计算左边和
            1. 如果左边和大于了n 说明k选的有点大，因此r=mid
            2. 如果左边和小于了n 说明k选的有点小，因此l=mid+1
            3. 相等 直接返回结果

    本题收获:
        这种数学问题:
            1. 先建模
            2. 尝试化简
            3. 如果所求变量比较少，就尝试枚举出变量的取值范围
            4. 尝试进行放缩

*/

class Solution {
public:
    string smallestGoodBase(string n) {
        long long num = stoll(n);
        long long m_maxi = log2(num)+1,m,i;
        for ( m=m_maxi; m>=2; --m ){
            long long mid, l=2, r=powl(num, 1.0/(m-1))+1;
            while( l<r ){
                mid = l+(r-l)/2;
                long long sum=0;
                for ( int i=0; i<m; ++i )
                    sum = sum*mid+1;
                if ( sum==num ) return to_string(mid);
                else if( sum>num ) r = mid;
                else l = mid+1;
            }
        }
        return "";
    }
};