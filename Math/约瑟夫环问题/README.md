# Josephus problem

刷空间的时候看到了这个问题。。 顺手尝试推了一下公式。。 理解公式的思想以后便可以记的更牢，也可以举一反三。。

约瑟夫问题:
    对N个人编号，然后围成一圈，从第一个开始报数，第M个将被杀掉；然后从第M+1个开始从头报数，最后杀到只剩下一个。然后求最后能存活下来的那个人的编号。


方法一:
    可以通过模拟来做，复杂度为O(N^2), 这个方法就不说了。

方法二: 公式法
    如果用递推式来想的话，首先找一个保存结果的状态.. 因为涉及的参数为:
        1. n: 表示总共n个人
        2. m: kill第m个人
    所以就令 f( n, m ) 返回 在n个人中，不停的带走第m个人，最后剩下那一个人的编号. 

    然后开始找f(n,m) 和 f(n-1,m)的关系, 先来看下面的例子:
    假设n=11, m=3:

    f(11,3):
    old_idx:    0 1 2 3 4 5 6 7 8 9 10
                    x 
    干掉第2个人之后，重新编号:

    new_idx:          0 1 2 3 4 5 6 7 
                8 9 

    可以发现，如果把new_idx向前移动3个单位(也就是m个单位)之后，下一次的操作就变成了

    idx:   0 1 2 3 4 5 6 7 8 9 

    也就是 f(10, 3)的情况..

    不难看出，在 f(11,3)里宰掉第3个人之后，整个数组在长度为n的窗口内向前移动m个偏移之后，下一次操作就是f(10, 3)的情况..

    而f(n,m)得到的是还剩一个元素时，那个元素的下标.. 所以是从后向前逆推的一个过程，也就是说：
        我们通过左移数组m个单位，得到了f(n,m)到f(n-1,m)的坐标转换，
        那么在已经知道f(n-1, m)中剩下的最后一个元素的坐标之后，向右移回m个单位，就能得到结果在f(n,m)中的坐标情况.. 

    理解了上面说的，得出公式就很easy了:

```cpp
int f(int n, int m):
    if ( n==1 ) // 如果还剩一个，那么编号一定为0
        return 0;
    return ( f(n-1,m) + m ) % n;  // 数组向右偏移m个单位
```

    如果要求下标从1开始怎么办呢?
        解决方法很简单， f(n, m)返回的是从1开始的，

        如果简单的对上面的公式中返回值加1:
            return ( f(n-1,m) + m ) % n + 1 ;
        这样是不对的，因为在里面偏移的处理时，我们是基于下标从0开始来计算的，
        不过只要在把1这个偏移量给剪掉就行了:
            return ( f(n-1,m)-1 + m ) % n + 1;
        这个结果就是对的了..

```cpp
// 下标从1开始:

int f(int n, int m):
    if ( n==1 ) // 如果还剩一个，那么编号一定为1
        return 1;
    return ( f(n-1,m)-1 + m ) % n + 1 ;  // 数组向右偏移m个单位
```

[练手题目](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)