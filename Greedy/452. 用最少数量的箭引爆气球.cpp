/*
    问题描述:
        在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。

        一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

        Example:

        输入:
        [[10,16], [2,8], [1,6], [7,12]]

        输出:
        2

        解释:
        对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。

    问题分析:
        
        用贪心来做。 

        贪心方法是： 只要让每一次射出的箭都是射穿当前区间的最大交集的就行。 

        看下面这个例子：
           a[0]  a[1]
        a    ——————
        b      ——————
        c        ——————
        d             ————————
        第一箭肯定是在a[1]的前面，所以我们看，在a[1]的前面最多能射掉几个，也就是只要区间的起始点在a[1]的前面的，我们都给合并起来。

        然后这样合并下去， 看能合并成几个； 

        如果合并成了k个， 那么射出k枝箭就行了。

        因此，我们先对区间的end进行排序，然后再来合并贪心。。（并不是真的合并，只要计算出最后能合并成的个数就行
*/

class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort( points.begin(), points.end(),[](vector<int>&a, vector<int>&b){
            return a[1]<b[1];
        } );
        int j, res = 0, i=0;
        while( i<points.size() ){
            j = i+1;
            while( j<points.size() && points[j][0]<=points[i][1] )
                ++j;
            ++res;
            i = j;
        }
        return res;
    }
};

