/*
    问题描述:
        有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 "x" 和 "y"，你需要通过「交换字符」的方式使这两个字符串相同。
        每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。
        交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。
        最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。
         

        示例 1：

        输入：s1 = "xx", s2 = "yy"
        输出：1
        解释：
        交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。
        示例 2：

        输入：s1 = "xy", s2 = "yx"
        输出：2
        解释：
        交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。
        交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。
        注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。
        示例 3：

        输入：s1 = "xx", s2 = "xy"
        输出：-1
        示例 4：

        输入：s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"
        输出：4
         

        提示：

        1 <= s1.length, s2.length <= 1000
        s1, s2 只包含 'x' 或 'y'。
    
    问题分析:
        同一个位置，考虑到四种情况:
            x->x
            y->y
            x->y
            y->x
        对于x->x 和 y->y可以不用考虑了，

        而x->y和y->x对应:
            xx->yy 和 xy->yx 的情况 
        xx->yy需要交换一次， 
        xy->yx需要交换两次，

        因此，x->y的情况数 / 2 + y->x的情况数/2 就解决了所有 xx->yy的情况

        而如果 只剩下 x->y 或 只剩下 y->x，那么将无法完成匹配

        如果一个都不剩下，那么就返回 x->y的情况数 / 2 + y->x的情况数/2 
        
        如果 既剩下一个x->y 又剩下一个y->x 那么正好匹配 成 xy->yx的情况， 需要交换2次。

        了解完就可以写程序了。
*/

class Solution {
public:
    int minimumSwap(string s1, string s2) {
        int a=0, b=0; // a记录x->y的情况数， b记录y->x的情况数
        for ( int i=0; i<s1.size(); ++i ){
            if ( s1[i]==s2[i] ) continue;
            if ( s1[i]=='x' && s2[i]=='y' ) ++a;
            else if ( s1[i]=='y' && s2[i]=='x' ) ++b;
        }
        if ( a%2==0 && b%2==1 || a%2==1 && b%2==0 ) return -1;
        return a/2 + b/2 + ( (a%2) *(b%2) )*2;
    }
};
