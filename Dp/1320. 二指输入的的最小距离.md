## 问题描述

![图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/leetcode_keyboard.png)

二指输入法定制键盘在 XY 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处，例如字母 A 位于坐标 (0,0)，字母 B 位于坐标 (0,1)，字母 P 位于坐标 (2,3) 且字母 Z 位于坐标 (4,1)。

给你一个待输入字符串 word，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。坐标 (x1,y1) 和 (x2,y2) 之间的距离是 |x1 - x2| + |y1 - y2|。 

注意，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。

 

示例 1：

    输入：word = "CAKE"
    输出：3
    解释： 
    使用两根手指输入 "CAKE" 的最佳方案之一是： 
    手指 1 在字母 'C' 上 -> 移动距离 = 0 
    手指 1 在字母 'A' 上 -> 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2 
    手指 2 在字母 'K' 上 -> 移动距离 = 0 
    手指 2 在字母 'E' 上 -> 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1 
    总距离 = 3

示例 2：

    输入：word = "HAPPY"

    输出：6

    解释： 

    使用两根手指输入 "HAPPY" 的最佳方案之一是：
    手指 1 在字母 'H' 上 -> 移动距离 = 0
    手指 1 在字母 'A' 上 -> 移动距离 = 从字母 'H' 到字母 'A' 的距离 = 2
    手指 2 在字母 'P' 上 -> 移动距离 = 0
    手指 2 在字母 'P' 上 -> 移动距离 = 从字母 'P' 到字母 'P' 的距离 = 0
    手指 1 在字母 'Y' 上 -> 移动距离 = 从字母 'A' 到字母 'Y' 的距离 = 4
    总距离 = 6
示例 3：

    输入：word = "NEW"
    输出：3

示例 4：

    输入：word = "YEAR"
    输出：7
 

提示：

    2 <= word.length <= 300
    每个 word[i] 都是一个大写英文字母。

## 问题分析
### 方法一: 动态规划

目标是少的操作次数，假设每一个字符都是一个节点，前面的字符可以访问其右方的任意一个字符，因此，可以抽象成一个有向图. 然后我们的目标就是，找到两条路径，这两条路径经过所有的节点，且这两条路径的和最小.   因为是两条路径，所以就不能用最短路径的方法去求了.   这里的子问题应该比较好看出来， 即，第i个位置可以访问[i+1,n]的任意一个位置的节点， 假设访问j, 那么如果已经知道了[j,n]的 最短距离和，这时，就可以用 dis(i,j) + [j,n]的最短距离和， 因此，可以看出是个自底向上的过程。   

dp[i][a][b]表示 打出[i,n]这个区间内的字符串且左手指以字符a开始，右手指以字符b开始，所需要移动的最小距离。  我们可以加一个“虚拟节点”， 设其为'[' （ascii码为'Z'+1)  ， 即dis(c, '[') 表示当前首次按下字符c，距离开销为0. （ps: dis(a,b)表示从字符a移动到字符b所需要的距离..)

状态转移也很好写了:
    dp[i][s[i]][b] = min{ dis(s[i], a) + dp[i+1][a][b] }
    dp[i][a][s[i]] = min{ dis(s[i], b) + dp[i+1][a][b] }
    
```cpp
# define inf 0x3f3f3f3f
class Solution {
public:
    int minimumDistance(string s) {
        int n = s.size();
        int dp[n+1][27][27];
        for ( int i=0; i<=n; ++i )
            for ( int j=0; j<27; ++j )
                for ( int k=0; k<27; ++k )
                    dp[i][j][k] = inf;
        dp[n][26][26] = 0;
        for ( int i=n-1; i>=0; --i ){
            for ( int a=0; a<=26; ++a )
                for ( int b=0; b<=26; ++b )
                    if ( dp[i+1][a][b]<inf ){
                        dp[i][s[i]-'A'][b] = min( dp[i][s[i]-'A'][b], dis( s[i]-'A', a ) + dp[i+1][a][b]);
                        dp[i][a][s[i]-'A'] = min( dp[i][a][s[i]-'A'], dis( s[i]-'A', b ) + dp[i+1][a][b]);
                    }
        }
        
        int res = INT_MAX;
        for ( int a=0; a<=26; ++a )
            for ( int b=0; b<=26; ++b )
                res = min(res, dp[0][a][b]);
        return res;
                                                 
    }
    
    int dis( int a, int b ){
        if ( a==26 || b==26 ) return 0;
        return abs( a/6 - b/6 )+abs(a%6 - b%6);
    }
};
```

### 方法二: 记忆化搜索
to do..