/*
    问题描述:
        有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

        每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

        找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。

         

        示例 1：

        输入：stones = [3,2,4,1], K = 2
        输出：20
        解释：
        从 [3, 2, 4, 1] 开始。
        合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
        合并 [4, 1]，成本为 5，剩下 [5, 5]。
        合并 [5, 5]，成本为 10，剩下 [10]。
        总成本 20，这是可能的最小值。
        示例 2：

        输入：stones = [3,2,4,1], K = 3
        输出：-1
        解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.
        示例 3：

        输入：stones = [3,5,1,2,6], K = 3
        输出：25
        解释：
        从 [3, 5, 1, 2, 6] 开始。
        合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
        合并 [3, 8, 6]，成本为 17，剩下 [17]。
        总成本 25，这是可能的最小值。
         

        提示：

        1 <= stones.length <= 30
        2 <= K <= 30
        1 <= stones[i] <= 100

    问题分析:
        1. 过滤不可能的情况
            看能不能合并成一个数. 判断的方法可以用逆推的想法.
        即 看最终合并成一个数的话，需要具备怎样的条件.

        最终: 1
        上一步: K
        上上一步: K-1 + K
        上上上一步: K-1 + K-1 + K
        ...
        数学归纳法证一下(其实都可以看出来了)
        合并成一个元素的必要条件就是 (N-1)%(K-1)==0

        因此用这个条件先过滤掉不可能的情况.

        2. 然后考虑区间Dp:
            本题和戳气球那一题略像，都是每次都会对操作的区间进行改变， 戳气球那一题是因为每次把气球戳破之后，气球就从区间消失了，
        而本题是每次合并区间以后，这个区间就变成了一个数了。

        这类题大多都是用区间dp来做， 难点主要在于状态的保存与推导上.

        首先确定dp[i][j]保存的是什么..


        先分析一下题目:
            把[i...j]合并成一堆的代价分为两个部分: old_cost + cur_cost:

                old_cost代表[i..j]的内部已经合并成了t堆， 还剩 k-t个数字, 那么在合并出t堆所需要的代价就是old_cost,
                (例如 给定[3,5,1,2,6], k=3, 然而[0..3]并不能合并成一个数，而是合并成 [3,{5,1,2}], 此时, dp[0][3]所保存的就是合并{5,1,2}所需要的代价, 这个情况就是： 已经合并了1堆{5,1,2}，还剩1个数字（3）)

                cur_cost： 把这区间内的所有都合并成一堆，所需要的代价， 即sum{ stones[i:j] }, 这个比较好理解，就不多说了

            [i..j]合并成一堆之后:
                1. 这一堆可能是最后结果，
                2. 也可能是下一次某个更大的区间[a...b] (a<i<j<b) 里的其中一个堆.

            因为cur_cost的值是固定的sum{ stones[i:j] }, 并且发生的条件也知道( (区间长度-1) % (k-1) ==0 )
            所以，dp[i][j]就专门保存old_cost。 这个old_cost就是:  [i..j]内有x堆和y个数字, 合并成t堆所需要的代价.

            所以再整理一下:
                dp[i][j]保存的内容是:
                    把区间[i,j]合并成 “x堆和个y数字” 这种样子，所需要的最小代价

                所以，对于更新dp[i][j]:
                    dp[i][j] = min( dp[i][j], dp[i][k] + dp[k+1][j]  )


                而当[i..j]可以合并成一堆的时候:
                    合并[i..j]所需要的最小代价 = min{ old_cost } + sum{ stones[i:j] }
                                             = dp[i][j] + sum{ stones[i:j] }

                合并之后，也可以看作是 1堆0个数字的old_cost

                因此，如果dp[i][j]可以合并成1个数字的话，就直接
                    dp[i][j] += sum{ stones[i:j] }

            综上, 本题的状态转移为:
                dp[i][j] = min( dp[i][j], dp[i][k] + dp[k+1][j]  )
                if ( [ (j-i+1) - 1 ] % (k-1) == 0 ):
                    dp[i][j] += sum{ stones[i:j] }
*/

class Solution {
public:
    int mergeStones(vector<int>& stones, int K) {
        int n = stones.size();
        if ( (n-1)%(K-1)!=0 ) return -1;
        int sums[n+1];
        int dp[n+1][n+1];
        memset( dp,0,sizeof(dp) );
        memset( sums,0,sizeof(sums) );
        for ( int i=1; i<=n; ++i )
            sums[i] = sums[i-1] + stones[i-1];
        for ( int len = K; len<=n; ++len ){
            for ( int i=1; i+len-1<=n; ++i ){
                int j = i+len-1;
                dp[i][j] = INT_MAX;
                for ( int t=i; t<j; t+=(K-1) )
                    dp[i][j] = min( dp[i][j], dp[i][t]+dp[t+1][j] );
                if ( (j-i)%(K-1)==0 )
                    dp[i][j] += (sums[j]-sums[i-1]);
            }
        }
        return dp[1][n];
    }
};