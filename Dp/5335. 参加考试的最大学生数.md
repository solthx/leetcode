# 问题描述
给你一个 m * n 的矩阵 seats 表示教室中的座位分布。如果座位是坏的（不可用），就用 '#' 表示；否则，用 '.' 表示。

学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。

学生必须坐在状况良好的座位上。

     

示例 1：

![pic](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/09/image.png)

    输入：seats = [["#",".","#","#",".","#"],
                  [".","#","#","#","#","."],
                  ["#",".","#","#",".","#"]]
    输出：4
    解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 

示例 2：

    输入：seats = [[".","#"],
                  ["#","#"],
                  ["#","."],
                  ["#","#"],
                  [".","#"]]
    输出：3
    解释：让所有学生坐在可用的座位上。

示例 3：

    输入：seats = [["#",".",".",".","#"],
                  [".","#",".","#","."],
                  [".",".","#",".","."],
                  [".","#",".","#","."],
                  ["#",".",".",".","#"]]
    输出：10
    解释：让学生坐在第 1、3 和 5 列的可用座位上。
 

- 提示：

1. seats 只包含字符 '.' 和'#'
2. m == seats.length
3. n == seats[i].length
4. 1 <= m <= 8
5. 1 <= n <= 8


# 问题分析：
    
    比赛的时候没做出来.. 回溯超时, 二分图模版往上套也没套对。。(好像用网络流可以做。。那个就不学了。。)

    赛后看到题解里说 按行进行状态压缩然后用Dp做的时候，才恍然大悟.. 被自己蠢哭了..

    在本题中，也是找依赖关系.. ( 和昨晚双周赛的最后一题也讨论了一波依赖来着..

    在本题中， 一个'.'的位置能不能坐，将由其左上，右上，左边，右边的位置的状态决定，
    也就是当前行的状态 依赖于：
        
        1. 上一行的状态 
        2. 自身的合法性， 自身的合法性主要是:
            2.1 只有空位才可以坐学生， 非空位不可以坐学生 (枚举的所有状态也是每一个空位下，坐和不坐的枚举组合.. )
            2.2 同一行的学生不能连续坐在一起.

    如果我们按行压缩的话，就可以枚举当前行的所有状态，然后计算出到对应状态下为止 可以坐的最多学生总数.. 

    知道了上面的思路，实现也不太难了，但要注意， 对于条件判断比较长的时候:
        1. 抽离出来单独成一个check函数
        2. if分层一定要清晰有条。。 不要揉在一起，不然容易出错

    赛后反思：
        看到数据量小的时候，也不能盲目暴力，一定要先分析题目，在算法的正确性和复杂度都ok的情况下再coding！！！先分析！再下手！！
        
        在考虑状压的时候，不能光凭经验想（凭借经验也很重要，通过本题，之后就会想能不能按行压缩之类的考虑），要根据依赖关系去想。。 就像本题，从一个位置上一行的两个位置的依赖，上升到当前行对上一行的依赖。。 然后枚举来做。。

        经过今天和昨晚的周赛， 让我认识到分析依赖关系是多么的重要。。即使在高压环境下，也要冷静思考，不能急于coding..

cpp solution
```cpp
class Solution {
public:
    int n,m;
    int maxStudents(vector<vector<char>>& seats) {
        n = seats.size(), m=seats[0].size(); 
        int dp[9][1<<8]={0};
        int state[9]={0};
        // 预处理，每行的情况
        // 0是空位，1是坏的位置
        for ( int i=1; i<=n; ++i ){
            for ( int j=0; j<m; ++j ){
                if ( seats[i-1][j] != '.' )
                    state[i] |= (1<<j);   
            }
        }
        int res= 0;
        for ( int i=1; i<=n; ++i ){
            for ( int pre=0; pre<1<<m; ++pre ){
                // 坏的位置不能坐人，因此不需要枚举
                if ( (pre&state[i-1])!=state[i-1] ) continue;
                for ( int cur=0; cur<1<<m; ++cur  ){
                    // 坏的位置不能坐人，因此不需要枚举
                    if ( (cur&state[i])!=state[i] ) continue;
                    int cnt = 0;
                    // ok表示当前行与上一行是否合法
                    bool ok=true;
                    // 检查cur与pre的组合是否合法，枚举每一位
                    for ( int k=0; k<m; ++k ){
                        if ( !check(cur, pre, k)  ){
                            ok=false;
                            break;
                        }   
                        cnt += (cur&(1<<k))==0;
                    }
                    // 如果合法就更新
                    if ( ok )
                        dp[i][cur] = max(dp[i-1][pre]+cnt, dp[i][cur]);
                    if (i==n)
                        res = max(res, dp[i][cur]);
                }
            }
        }
        return res;
    }
    
    bool check( int cur, int pre, int k ){
        if (  (cur&(1<<k))==0 ){
            if ( k>0 && ( pre & (1<<(k-1)) ) == 0 ) return false;
            if ( k<m-1 && ( pre & (1<<(k+1)) ) == 0 ) return false;
            if ( k>0 && ( cur & (1<<(k-1)) ) == 0 ) return false;
            if ( k<m-1 && ( cur & (1<<(k+1)) ) == 0 ) return false;
        }
        return true;
    }
    
};
```