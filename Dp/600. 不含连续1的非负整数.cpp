/*
    问题描述:
        给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。

        示例 1:

        输入: 5
        输出: 5
        解释:
        下面是带有相应二进制表示的非负整数<= 5：
        0 : 0
        1 : 1
        2 : 10
        3 : 11
        4 : 100
        5 : 101
        其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
        说明: 1 <= n <= 10^9

    问题分析:
        O(N)肯定会TLE，不然就不是hard了..

        可以从位的长度来入手, 即:
            dp[i][0] 表示 二进制长为i，首位为0 满足题目条件的数字个数. (条件就是二进制不包含连续的1)
            dp[i][1] 表示 二进制长为i, 首位为1 满足题目条件的数字个数.

        状态转移很好写:
            dp[i][0] = dp[i-1][0] + dp[i-1][1]
            dp[i][1] = dp[i-1][0]

        然后就是给定一个数字，求小于等于这个数字的个数..

        这个可以通过一个例子来进行分析:
            例如:  10110

            第一位，长位5，10110:
                首先第一位是1, 所以 dp[5][0]的所有情况 一定都可以取到。 因为1xxxx一定大于01111 这个就不用解释了.
                但dp[5][1]的情况能不能取到，就要看当前位的后一位是不是1了，因为，一定不会出现连续两个1，所以 dp[5][1]里的每一个数的情况一定都是
                10xxxx 这种样子的. 所以，如果当前位的后一位是1，那么直接返回 < 当前位之前的个数 + dp[i][1] + dp[i][0] >

                如果后一位是0，这个情况就要继续向后传递了, 就比如这个例子, 第1位是1，后一位是0，所以我们先加上 0开头 的所有情况(dp[5][0])，然后再向后讨论1开头的情况.

            第二位, 长位4，0110：
                第二位是0，因为要讨论0的取值情况，所以继续向后传递.

            第三位, 长为3， 110：
                第三位是1， dp[3][0]是一定可以取到的，然后因为当前位的后一位是1，因此dp[3][1]一定也可以取到, 然后后面的就不需要讨论了.

            因此，就返回dp[5][0] + dp[3][1] + dp[3][0]


        然后我们就找到了规律:
            对于当前位是1的情况 , 我们一定可以加上dp[i][0]，i为以当前位为首的二进制长度.

            但至于能不能取尽dp[i][1]则需要看当前位的后一位是不是1 ， 如果是，则可以取尽dp[i][1], 然后所以情况就取完了，加上之前取的个数就可以返回了.

            如果后一位不是1，则要 先加上 dp[i][0], 这是一定可以取到的, 即0xxxxx的所有情况,
            然后讨论[10xxxx, 当前数] 这个区间里能取到几个， 子问题就变成[xxxx, 当前数低4位 ] ，即 把问题向后传递。。

        再简化一下就变成了:
            i = len(num)
            while( i>0 ):
                当前位是1:
                    后一位是1:
                        return res + dp[i][0] + dp[i][1]
                    后一位不是1:
                        res += dp[i][0]
                --i;

        因为是自己强行想的.. 感觉做法不是特别优雅.. 实现的也比较粗糙.. 二刷的时候再重写一遍吧..
*/

class Solution {
public:
    int findIntegers(int num) {
        // dp[i][0] 表示 长为i，且以0为起使的个数
        // dp[i][0] 表示 长为i，且以1为起使的个数
        int dp[40][2]={0};
        string s = helper(num);
        int len = s.size();
        dp[1][0] = dp[1][1] = 1;
        for ( int i=2; i<=len; ++i ){
            dp[i][1] = dp[i-1][0];
            dp[i][0] = dp[i-1][0] + dp[i-1][1];
        }
        int i=len-1, res = 0;
        while( i>0 ){
            if ( s[i]=='1' ){
                if ( s[i-1]=='1' ) return res + dp[i+1][0] + dp[i+1][1];
                else res += dp[i+1][0];
            }
            --i;
        }
        // 因为每次要判断前1位，所以长为1的情况会没有讨论, 长为1的时候，如果是0，就加上dp[1][0],
        // 如果是1就加上dp[1][0]+dp[1][1] 这里直接用数字代替了
        // 实现的太粗糙了T_T 之后再重写吧..
        return s[0]=='0'?res+1:res+2;
    }

    string helper( int num ){
        string res;
        while( num>0 ){
            res += to_string(num%2);
            num/=2;
        }
        return res;
    }
};