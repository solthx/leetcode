# 问题描述
给你三个整数 n、m 和 k 。下图描述的算法用于找出正整数数组中最大的元素。
![pic](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png)
请你生成一个具有下述属性的数组 arr ：

arr 中有 n 个整数。
- 1 <= arr[i] <= m 其中 (0 <= i < n) 。
- 将上面提到的算法应用于 arr ，search_cost 的值等于 k 。
- 返回上述条件下生成数组 arr 的 方法数 ，由于答案可能会很大，所以 必须 对 10^9 + 7 取余。

- 示例 1：

        输入：n = 2, m = 3, k = 1
        输出：6
        解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]

- 示例 2：

        输入：n = 5, m = 2, k = 3
        输出：0
        解释：没有数组可以满足上述条件

- 示例 3：

        输入：n = 9, m = 1, k = 1
        输出：1
        解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]
- 示例 4：

        输入：n = 50, m = 100, k = 25
        输出：34549172
        解释：不要忘了对 1000000007 取余
- 示例 5：

        输入：n = 37, m = 17, k = 7
        输出：418930126
         

提示：

- 1 <= n <= 50
- 1 <= m <= 100
- 0 <= k <= n

# 问题分析:

理解完上一段的代码之后，其实就是找长度为n，可以取值的范围为[1,m]，恰好存在k个上坡次数的序列个数( 初始位置为负数，所以第一次一定是上坡 )

其实看到这个数据量，就不难想到dp[i][j][k]用于保存"前i个元素中，第i个元素的大小为j，恰好上坡了k次“的组合个数，这种dp的解决，往往我们先考虑：
- 初始化最开始的情况，即使dp[1][j][k]的情况
- 从**最后一个变量**开始找状态转移。


## 1. 初始化
初始化i=1的情况，我们可以知道，如果i=1, 就是只有一个元素：
- 如果k小于1:肯定是0
- 如果k大于1:肯定是0
- 如果k等于1:那么无论j取什么值，都只能是1

## 2. 状态转移

接下来就是找状态转移方程，也就是看第i个数的所有取值情况可以由哪些子情况组成（就是dp[i][j][k]会是怎样得到的）：

- 讨论第i个值，希望确定的是dp[i][j][k]
    - 1. 如果取的第i个值能够成为前i个元素的最大值(也就是j)，那么第i-1个位置就可以取 {1..j-1} 也就是，那么可以是：dp[i-1][1..j-1][k-1]，也就是 sums{dp[i-1][1..j-1][k-1]}  
    - 2. 如果取的第i个值不能成为最大值（也就是小于j），那么一定是从dp[i-1][j][k]里得到的，但是这个不是最大值的数的取值范围为[1,j]即一共有j种，故这类子情况占 j*dp[i-1][j][k]个



```cpp
class Solution {
public:
    int numOfArrays(int n, int m, int k) {
        if ( m<k ) return 0; // 一定不可能的情况
        const int mod = 1e9+7;
        long long dp[101][101][101]={0};
        
        for(int i=1; i<=m; ++i)
            dp[1][i][1] = 1;
        for(int i=2; i<=n; ++i)
            for(int j=1; j<=m; ++j){
                for(int z=1; z<=j; ++z){
                    for(int j_=1; j_<=j-1;++j_)
                        dp[i][j][z] += dp[i-1][j_][z-1];
                    dp[i][j][z] += dp[i-1][j][z]*j;
                    dp[i][j][z] %= mod;
                }
            }
        long long res = 0;
        for(int i=0; i<=m; ++i){
            res += dp[n][i][k];
            res %= mod;
        }
        return res;
    }
};
```

