/*
    问题描述:
        给你一个由小写字母组成的字符串 s，和一个整数 k。

        请你按下面的要求分割字符串：

        首先，你可以将 s 中的部分字符修改为其他的小写英文字母。
        接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。
        请返回以这种方式分割字符串所需修改的最少字符数。

         

        示例 1：

        输入：s = "abc", k = 2
        输出：1
        解释：你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。
        示例 2：

        输入：s = "aabbc", k = 3
        输出：0
        解释：你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。
        示例 3：

        输入：s = "leetcode", k = 8
        输出：0
         

        提示：

        1 <= k <= s.length <= 100
        s 中只含有小写英文字母。

    问题分析:
        
        看起来像是区间dp, 如果是区间dp的话， f[i][j][t]保存 把区间[i,j]分成t个回文串所需要的最小代价.

        大概思考一下
            len : n
                i : n
                    t : n
                        [i,j] : n
        复杂度估计至少O(N^4).. （虽然听说有N^4过的..

        所以，另辟蹊径，不再用区间dp， 就用一个普通的二维dp:
            f[i][j]保存 把区间[0，i]分成j个回文串所需要的最小代价.

        接下来就是考虑怎么更新状态，一般这种保存第i个元素为结尾的状态的，
        一般是 f[i]= f[t] + state[t+1,i] 这样子来更新的，
        

        本题最大的难点就在于，能不能转换到下面这个转移

        f[i][j] = min{ f[t][j-1] + {把区间[t+1,j]变为1个回文串的最小代价} }
        
        {把区间[t+1,j]变为1个回文串的最小代价} 可以来做一个预处理

        即: dp[i][j] 保存了 把区间[t+1,j]变为1个回文串的最小代价

        然后上面的转移就是

        f[i][j] = min{ f[t][j-1] + dp[t+1][i] }

        然后注意处理好边界，之后就简单了.

        本题收获:
            做dp的题，经验法则来找 该保存什么状态 是一个重要的辅助手段，

            但这终究还是辅助的，

            尽量还是先找到 某一种情况 怎么通过更原子的情况来推导过来， 

            更重要的是！！！！

            推导时，或许并不仅仅是通过本身来进行推导，可能需要其他的状态( 例如本题 仅仅靠f[i][j] 是整不出来的，还再外加一个

            因此， 之后在进行推导的时候，不要形成了思维定式； 先看需要什么状态，然后再想办法挨个得到这些需要的状态（有可能会有多个）.. 

*/

class Solution {
    public int palindromePartition(String s, int k) {
        char[] st = s.toCharArray();
        int n = s.length();
        int[][] f = new int[n + 1][n + 1]; // f[i][j]记录把[i,j]变成回文的最少代价
        for (int len = 2; len <= n; ++len) {
            for (int i = 0; i + len <= n; ++i) {
                int j = i + len - 1;
                f[i][j] = len / 2;
                if (st[i] == st[j])
                    f[i][j] = f[i + 1][j - 1];
                else
                    f[i][j] = f[i + 1][j - 1] + 1;
            }
        }
        int[][] f = new int[n + 1][n + 1];
        for (int i = 1; i < n; ++i) {
            f[i][1] = f[0][i];
            for (int j = 2; j <= k; ++j) {
                f[i][j] = Integer.MAX_VALUE;
                for (int t = 0; t < i; ++t) {
                    f[i][j] = Math.min(f[i][j], f[t][j - 1] + f[t + 1][i]);
                }
            }
        }
        return f[n - 1][k];
    }
}