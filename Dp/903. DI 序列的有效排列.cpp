/*
    问题描述:
        我们给出 S，一个源于 {'D', 'I'} 的长度为 n 的字符串 。（这些字母代表 “减少” 和 “增加”。）
        有效排列 是对整数 {0, 1, ..., n} 的一个排列 P[0], P[1], ..., P[n]，使得对所有的 i：

        如果 S[i] == 'D'，那么 P[i] > P[i+1]，以及；
        如果 S[i] == 'I'，那么 P[i] < P[i+1]。
        有多少个有效排列？因为答案可能很大，所以请返回你的答案模 10^9 + 7.

    问题分析:
        本题属于比较难的dp了...看完题解才缓过来

        难点在于状态的转移.

        拿DID来举例子

        上升还是下降，跟最后一个数字的大小关系较大，
        所以我们把最后一个数字作为状态来保存.. 即 dp[i][d]表示 字符串长度为i时，以数字d为结尾的 满足字符串条件的 组合个数
        
        另外，如果当前是下降，那么当前的d可以取的范围就是[0,i-1]， 不能取到i， y因为i是最大的，如果取到i，那么不可能上升
        同理，如果是上升，那么只能取到[1,i], 因为0是最小的，如果当前位是0，那么不可能上升

        状态转移公式:
            一、如果是"D"：
                    那么当前位置需要考虑的就是[0,i-1], 
                    即利用dp[i-1][..] 来确定 dp[i][0~i-1] 的大小
                dp[i][k] : // 我要把k给加进来了！ 
                把k加进来之后，还要是下降的, 所以，
                dp[i][k] = dp[i-1][k] + dp[i-1][k+1] + ... + dp[i-1][i-1]
                        = sum{ dp[i-1][k ~ i-1] }

                这里解释一下为什么，
                    从 x1,x2,x3, 加进来一个i后，变成了  y1, y2, y3, k
                有点抽象哈, 举个具体的例子把：
                    DI: 102, 201
                    DI -> DID:
                        dp[3][0]的情况：
                            [1,0,2] 加进来一个3， 得到 [y1, y2, y3, 0]

                        我们希望，在不破坏原本位置之间的相对大小的情况下,完成上面的操作.

                        这里的方法是： 
                            对所有大于等于0的元素都+1， [1,0,2]->[2,1,3]
                            相当于把前面的序列劈成两部分, 
                            一部分是大于等于k的，
                            一部分是小于k的, 在这里，k等于0

                            把大于等于k的那一部分+1， 则不会影响相对顺序, 并且原本的i-1变成了i，原本的k变成了k+1，
                            完美的实现了 “在不改变相对大小的情况下, 加入i, 并且把k拿出来”

                            被拿出来的k，直接放到最后就可以了. 于是[2,1,3] -> [2,1,3,0] 

                        因此, dp[3][0] = dp[2][0] + dp[2][1] + dp[2][2] 
                            
                            dp[2][0]:  0->1 > 0 (倒数第二位和最后一位的比较, 倒数第二位因为+1的缘故, 所以0->1)
                            dp[2][1]:  1->2 > 0
                            dp[2][2]:  2->3 > 0
                        
                            dp[3][1] = dp[2][1] + dp[2][2]
                            
                            dp[2][1]:  1->2 > 1
                            dp[2][2]:  2->3 > 1
            二、 如果是"I"
                同理，
                dp[i][k] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][k-1]
                        = sum{ dp[i-1][0 ~ k-1] }
                分析的理论和上面差不多, 之所以是到k-1而不是到k，
                是因为倒数第二位要小于k ！

                如果倒数第二位取到k了，那么在+1操作之后，倒数第二位就会变成k+1, 最后一位是k， 显然不符合要求了。
            
        最后的答案就是 sum{dp[n][0~n]} 
            以上总结参考了:  https://www.cnblogs.com/grandyang/p/11094525.html
            
            ps:  爱奇艺高频考题.. 感觉好难..
*/

# define mod 1000000007
class Solution {
public:
    int numPermsDISequence(string S) {
        int n=S.size(), dp[201][201]={0};
        dp[0][0] = 1;
        for ( int i=1; i<=n; ++i ){
            if ( S[i-1]=='D' ){
                // 下降, 加入k in [0,i-1]
                for ( int k=0; k<=i-1; ++k )
                    for ( int j=k; j<=i-1; ++j )
                        dp[i][k] = ( dp[i][k] + dp[i-1][j] ) %mod;
            }else if ( S[i-1]=='I' ){
                // 上升，加入[1,i]
                for ( int k=1; k<=i; ++k )
                    for ( int j=0; j<k; ++j )
                        dp[i][k] = ( dp[i][k] + dp[i-1][j] ) %mod;
            }
        }
        int res = 0;
        for ( int i=0; i<=n; ++i )
            res = (res + dp[n][i])%mod;
        return res;
    }
};