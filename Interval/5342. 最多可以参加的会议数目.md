# 问题描述

    给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。

    你可以在满足 startDayi <= d <= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。

    请你返回你可以参加的 最大 会议数目。

 

示例 1：

![pic](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png)

    输入：events = [[1,2],[2,3],[3,4]]
    输出：3
    解释：你可以参加所有的三个会议。
    安排会议的一种方案如上图。
    第 1 天参加第一个会议。
    第 2 天参加第二个会议。
    第 3 天参加第三个会议。

示例 2：

    输入：events= [[1,2],[2,3],[3,4],[1,2]]
    输出：4

示例 3：

    输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]]
    输出：4

示例 4：

    输入：events = [[1,100000]]
    输出：1

示例 5：

    输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]
    输出：7

- 提示：
    1. 1 <= events.length <= 10^5
    2. events[i].length == 2
    3. 1 <= events[i][0] <= events[i][1] <= 10^5

# 问题分析:
    
    =======基于经验的思路===========
    要求最多的区间，很容易想到对区间的右边界进行排序. 但如果仅仅根据右边界进行选位的话，
    对于
        [2,3],[2,3], [1,5],[1,5],[1,5] 
    的case就会wa..

    因为，我们会先在时间轴 1的位置上选[1,5], 然后在2和3的位置上选[2,3]和[2,3]，然后在剩下的两个继续选[1,5]。。 

    因为我们要根据时间递增的顺序，来贪心地确定当前位置选哪个区间.. 所以如果仅仅考虑右边界的话，是不够的，说明我们还要考虑左边界..

    =======上面是基于经验的思路，下面来分析问题============

    换个角度来看，我们在确定时间t这个位置上该取哪个区间的时候，
    
    我们希望尽量接近区间的右边界！！
    这个很好理解，比如[2,2], [2,3]在确定位置2的时候，如果我们选了[2,3]，那么过了时刻2之后，[2,2]就没法选了， 反而[2,3]还可以选，这显然不合理.. 所以我们希望在时刻t尽量取右边界更接近当前时刻的区间..

    所以，对于确定时间应该选哪个区间(就是取哪个会议), 我们希望在t时刻的这个区间满足:
    
        1. event[i][0]<=t
        2. min{event[i][1]-t}
    
    所以我们可以维护一个堆，用来保存在时间t时，满足event[i][0]<=t的所有区间！！！ 

    到这里，就已经可以写了。。

    方法一:
        可以预处理区间数组，数组倒排一下，得到以时间t为左边界的所有区间。。
        然后遍历时间t from [ l, r ] 按照上面的思路动态维护heap就行

    方法二:
        还可以先对数组对左边界先进行排序，然后根据左边界来递增处理..

    小结:
        感觉这题是非常棒的一题..  本题的收获:
            之前做的类似的这种关于区间的贪心题 ，都是对左边界进行排序或者右边界进行排序，然后维护一些变量数据就可以递增的根据时间线来扫描了。。。 当发现这题不仅要看右边界，还要看左边界的时候，还以为应该用dp来做。。结果没想出来。。

            虽然这题确实不能仅仅看右边界，但这时还要具体分析在时间t这个时刻，对左右边界的要求条件是什么样子的。
            
            如果当时冷静下来分析在每个时间t 
            "应该取的区间"所要满足的条件的话， 当时就能发现只要满足左边界<=t就行了，这样的话，直接滚动就可以做了！ 

            ！！！因此，当做这种贪心的题的时候，如果发现对左右区间都有要求，那么还要看一下具体是什么样的要求，  因为我们在遍历时间的时候就是递增的，或许可以在遍历的过程中 滚动的就满足了其中一个要求了！！ 另一个边界的要求用堆就可以来完成！！

            所以感觉本题还是比较好！！学到了新东西！！


```cpp
class Solution {
public:
    int maxEvents(vector<vector<int>>& events) {
        if (events.size()==0) return 0;
        auto cmp = [](vector<int>&a, vector<int>&b){
            return a[1]>b[1];  
        };
        int res=0;
        priority_queue<vector<int>,vector<vector<int>>,decltype(cmp)> q(cmp);
        unordered_map<int, vector<int>> vtoi;
        int l=INT_MAX,r=-1;
        for(int i=0; i<events.size(); ++i){
            // 数组倒排，保存 vtoi[t]保存以t为左边界的区间在events中的序号
            vtoi[events[i][0]].push_back(i);
            l=min(l,events[i][0]);
            r=max(r,events[i][1]);
        }
        // 递增确定每一个时间t应该取哪个区间
        for(int t=l; t<=r; ++t){
            // 先把以t开始的区间给丢到堆里取
            for(auto&start:vtoi[t])
                q.push(events[start]);
            // 过滤掉所有右边界也小于时间t的区间 (表示会已经开完了
            while(q.size()>0 && q.top()[1]<t) q.pop();
            // 然后此时如果堆里有数据的话，那么就取 右区间最接近当前t的那个区间！
            if(q.size()>0 && q.top()[0]<=t){
                q.pop();
                ++res; // 结果+1
            }
        }
        return res;
    }
};
```