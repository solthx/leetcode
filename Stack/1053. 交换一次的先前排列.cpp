/*
    问题描述:
        给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。
如果无法这么操作，就请返回原数组。
        示例 1：

        输入：[3,2,1]
        输出：[3,1,2]
        解释：
        交换 2 和 1
         
        示例 2：
        输入：[1,1,5]
        输出：[1,1,5]
        解释： 
        这已经是最小排列
         
        示例 3：
        输入：[1,9,4,6,7]
        输出：[1,7,4,6,9]
        解释：
        交换 9 和 7
         
        示例 4：
        输入：[3,1,1,3]
        输出：[1,3,1,3]
        解释：
        交换 1 和 3
        
        提示：

        1 <= A.length <= 10000
        1 <= A[i] <= 10000
    
    问题分析:
        这种样例给的多的题就很nice。。 列出几种情况，就能发现规律了。。
        就是交换一个最靠右边的逆序对，
        可以从i=n-1开始，通过从右向左遍历，构建递减栈来做
            1. 从右向左当发现首个 j>i, nums[j]<nums[i]的时候，开始不停出栈，找出栈中比nums[j]小的最大值
            2. 在出栈过程中，如果遇到A[t1]==A[t2]，且t1<t2，那么选t1， 因为这样能保证“字典序排列小于 A 的最大可能排列”

*/

class Solution {
public:
    vector<int> prevPermOpt1(vector<int>& A) {
        stack<int> s;
        if ( A.size()<=1 ) return A;
        if ( A.size()==2 ){
            swap(A[0], A[1]);
            return A;
        }
        // 找到首个比i大的元素
        int i=A.size()-1; 
        while( i>=0 ){
            // 构建递减栈
            if ( s.empty() || A[s.top()]>=A[i] ){
                s.push(i);
                i--;
            }else{
                // 发现首个递增
                int sav=-1;
                // 开始不停出栈，找出栈中比nums[j]小的最大值 的index
                // sav来记录那个比nums[j]小的最大值的index
                while( !s.empty() && A[s.top()]<A[i] ){
                    // 相等的话，选第一次遇到的那个index
                    if ( sav==-1 || A[sav]!=A[s.top()] )
                        sav = s.top();
                    s.pop();
                }
                swap( A[sav],A[i] );
                return A;
            }
        }
        return A;
    }
};