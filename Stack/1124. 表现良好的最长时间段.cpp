/*
    问题描述:
        给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。
        我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。
        所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。
        请你返回「表现良好时间段」的最大长度。

    
        示例 1：
        输入：hours = [9,9,6,0,6,6,9]
        输出：3
        解释：最长的表现良好时间段是 [9,9,6]。

    问题分析:
        提炼一下题目，
        给一个只有-1，1的数组，返回该数组中区间和大于0的最长区间长度.
        (大于8是1，小于8是-1)

        看到区间和问题，一开始用了归并排序去解，最终没解出来。
        归并排序确实可以处理区间和问题，不过那是只对值加条件限制的前提下，
        例如:区间和在某个范围内，区间和等于某个定值，区间和最大的，等等等等

        而本题不仅对值加了条件(大于0)， 还对区间长度加了条件(最大)
        但在归并排序的时候，会对前缀和数组的相对位置进行了破坏，
        
        被破坏的位置，无法在线性时间内处理中间情况
        
        (因为就算用pair记录了原始位置，但从 位置有序值无序，变成了值有序位置无序，
        故无法在线性时间内完成)

        正确解法:
            本题要求的就是区间和大于0的最长长度，
            也就是sum[i]-sum[j]>0  且|i-j|最大,i和j在空间上的距离最远

            看了题解才知道原来是单调栈的变种.

            单调栈一般用于求:
                1.比当前元素更大的下一个元素
                2.比当前元素更大的前一个元素
                3.比当前元素更小的下一个元素
                4.比当前元素更小的前一个元素

            具体详见 # 单调栈总结 

            本题是单调栈的变种， 因为要求的是
                最远的i和j，使得sums[i]<sums[j]，
            
            在本题中，我们维护一个递减栈，在“寻找比当前元素
            更大的下一个元素”的问题中， 我们是用递减栈，然后
            i从小到大正向遍历， 这样在顺序的前提下，就能找到首个
            满足sums[i]>stack.top() ，也就是说个比stack.top()大的元素

            但如果我们先建好这个递减栈， 然后反向遍历的话(i从大到小)，然后不停的把
            sums[i]和栈顶比较, 如果sums[i]>top() 也就是sums[i]-top()>0
            也就是这段区间和大于0， 我们就得到了以top()(假设为sums[j])所在的位置j开始
            的最远距离i 且sums[i]>sums[j] 。。 用到了贪心的思想。

            然后不停pop， 直到栈顶元素大于sums[i]， 然后i继续向左移动.
            这里我们为什么要将元素弹出呢？我们定义变量i、j1和j2，并且i < j1 < j2，
            此时如果pre_sum[j2] > pre_sum[i]的话，那么我们的pre_sum[j1]显然就不用再参与比较了，因为不可能比j2-i更大。

            关于这个递减栈的初始大小，本题中，将0作为递减栈的第一个元素，
            因为递减栈里的元素，是前缀和的下标(用来表示前缀和)，
            一个情况就是区间[1,i]满足了条件，
            那么应该用sums[i]-sums[0]，我们希望栈的第一个元素是最左边的前缀和
            也就sums[0]，前0个元素的和当然是0了。。 所以把0当前递减栈的第一个元素
            也可以想成是把sums[0]当作了第一个元素。
 */


class Solution {
public:
    int longestWPI(vector<int>& hours) {
        int res=0,n=hours.size();
        stack<int> st;
        vector<int> sums(n+1,0);
        
        // 构建前缀和
        for ( int i=1; i<=n; ++i ){
            if ( hours[i-1]>8 )
                sums[i] = sums[i-1] + 1;
            else sums[i] = sums[i-1] -1 ;
        }
        
        // 构建以首个元素为sum[0]的递减栈
        for ( int i=0; i<=n; ++i ){
            if ( st.empty() || sums[st.top()]>sums[i] ){
                st.push(i);
            }
        }
            
        // 从后向前遍历
        int j=n;
        while( j>=0 ){
            while ( !st.empty() && sums[st.top()]<sums[j] ){
                res = max( res, j-st.top());
                st.pop();
            }
            --j;
        }
        return res;
        
    }
};