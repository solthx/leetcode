/*
    问题描述:
        给定一个正整数 n，你可以做如下操作：
            1. 如果 n 是偶数，则用 n / 2替换 n。
            2. 如果 n 是奇数，则可以用 n + 1或n - 1替换 n。
            n 变为 1 所需的最小替换次数是多少？

        示例 1:
            输入:
            8

        输出:
            3

        解释:
            8 -> 4 -> 2 -> 1
        
        示例 2:
            输入:
            7

        输出:
        4

        解释:
            7 -> 8 -> 4 -> 2 -> 1
            或
            7 -> 6 -> 3 -> 2 -> 1

    问题描述:
        方法一: 搜索
            尽管这题没卡时间.. 但总感觉这题考的不是搜索.. 
            看了下标签，果然，考的是位运算

        方法二: 位运算+贪心
            
            分为奇偶的情况:
                1. 对于偶数的情况, 直接/2了，没啥好说的。
                2. 对于奇数的情况， 
                    xxy1
                    又分为两种: 
                        xx01 和 xx11
                        2.1 xx01
                            xx01 如果对其加1 右移，就会 变成xx1，操作两次
                            xx01 如果对其剪1 右移， 就会 变成xx0, 操作两次
                            显然，我们选择后者
                        2.2 xx11
                            同理的分析，
                                通过加1操作和右移，xx11能把后两个1消掉，然后产生个进位, 因此，消掉后两个1的代价为 2*1 +1
                                通过剪1操作和右移，xx11消掉后两个1 需要4次操作。
                            因此在这个情况，我们选择加1右移
                3. 特殊情况： 3
                    对于3的情况，11
                        因为我们的目标是得到1，

                        而对于2.2的情况，我们是一次消掉最后的两个1，
                        这样会把3 消成100, 显然又多了个冗余的操作 (如果要求结果是0的话，就不用单独讨论了)

                        因此，3的情况要单独处理。

                因此，最终，每一次该做的操作为:
                        if n是偶数:
                            n /= 2
                        else if  n是3 or n的最后两位不同为1:
                           --n
                        else if n不是3 && n的最后两位同时为1:
                            ++n 
*/

// dfs
class Solution1 {
public:
    int integerReplacement(int n) {
        int res = INT_MAX;
        dfs( res, n, 0 );
        return res;
    }
    void dfs(  int & res, long n, int cnt ){
        if ( n==1 ){
            res = min( res, cnt );
            return ;
        }
        if ( n%2==0 ) dfs( res, n/2, cnt+1 );
        else{
            dfs( res, n+1, cnt+1 );
            dfs( res, n-1, cnt+1 );
        }
    }
};

// 位运算+贪心
class Solution2 {
public:
    int integerReplacement(long n) {
        int res = 0;
        while( n>1 ){
            if ( n%2==0 ) n/=2;
            else if ( (n&1) && (n&2) && n>3 )
                ++n;
            else --n;
            ++res;
        }
        return res;
    }
};