/*
    问题描述:
        给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。
        
        说明：
            你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

            示例 1:

            输入: [2,2,3,2]
            输出: 3
            示例 2:

            输入: [0,1,0,1,0,1,99]
            输出: 99

    问题分析:
        该方法适用于求 "给一个非空数组， 除了某元素只出现一次以外，其余每个元素出现了k次， 找出出现一次的这个元素"

        即，一位一位的来计算,
        
        遍历所有数的第i位,
            如果第i位出现的次数 % k == 0
            说明第i位出现了k次， 那么只出现了一次的那个数的第i位肯定是0， 否则是1 
        
        由此来计算出只出现了一次的数的每一位，然后就得到了这个数
*/
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0, cnt=0;
        for ( int i=0; i<32; ++i ){
            // 判断出现一次的那个数的第i位是0还是1
            // 如果第i位出现的次数是k的倍数，说明出现一次的那个数在该位上是0，否则是1
            cnt=0;
            for ( auto e:nums ){
                cnt+= (e>>i)%2;
            }
            if ( cnt%3!=0 ) res+=(1<<i);
        }
      return res;
    }
};