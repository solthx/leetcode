/*
    问题描述:
        给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

        示例 :
            输入: [1,2,1,3,2,5]
            输出: [3,5]
        
        注意：
            结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
            你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

    问题分析:
        hashset和排序的方法就不说了，这里记录一下位运算的骚操作.
        本题的难点在于，数组中有两个不同的元素只出现了一次，如果只有一个不同的元素的话，我们可以通过 异或来解决。
        因为 a^a=0, a^0=a,  根据这个特性，把整个数组异或一遍，最后的那个值就是只出现了一次的元素,
        但因为本题是有两个出现了一次的元素，所以这么做不可行。

        假定本题中，a和b为只出现了一次的两个数.
        本题的思路就是，把数组分成两波，a出现在第一波，b出现在第二波.
        然后分波进行异或. 
        
        那么如何分波，就是本题的思路上的亮点了.

        首先，a^b 的二进制表示为，在每一个位上，如果a和b在该位上的数不同，那么该位就为1，
        
        所以，我们只要取任意一位，在那一位上，a和b一定是: 一个是0，一个是1
        
        在树状数组里，求lowbit的时候，我们是通过 x&-x来得到最低位的1 , 设其为mask
        
        数组元素被分为两波， 这两波元素的区别之处在于 ， (任意元素 & mask == mask ) 是否成立


        所以，算法步骤为: 
            1. 先求出 sign = a^b 
            2. 计算出mask = sign & -sign
            3. 重新遍历数组,
                b = 0
                for c:nums:
                    if ( ( c & mask)==mask )
                        b ^= c
            4. b是其中一个只出现了一次的元素，
                另外一个就是 sign^b ( 因为 sign^b = a^b^b= a ) 
*/

class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int mask;
        int sign = 0;
        for ( auto e:nums )
            sign ^= e;
        mask = sign & -sign;
        int res=0;
        for ( auto e:nums )
            if ( (mask&e)==mask )
                res ^= e;
        return { res, sign^res };
    }
};