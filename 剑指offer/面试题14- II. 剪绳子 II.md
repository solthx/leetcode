# 问题描述
    给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n 都是整数，n>1 并且 m≥1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。

    答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。


    示例 1：

    输入: 2
    输出: 1
    解释: 2 = 1 + 1, 1 × 1 = 1
    示例 2:

    输入: 10
    输出: 36
    解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
     

- 提示：

1. 2 <= n <= 1000

# 问题分析:
    因为本题多了一个多数据取模的操作，所以不能用Dp来做了

    例如 1e9+7+20 的个数 取了一个mod之后就变成了20.. 和其他情况比较的时候就不正确了..

    这里用的方法也是数学问题的常用解法: 演绎推理 (好吧，就是找规律)

    1. n<=3时:
        单独讨论, 答案为max(0, n-1)
    2. n>=3时:
        尽量把每一个数都用上，且多余的用2来组
        n%3==0:
            n/3 个 3 的积
        n%3==1:
            拿出一个3和余的1组成 2+2， 即 ((n/3)-1个3) 和4 的积
        n%3==2:
            和上面同理， (n/3个3) 和 2的积

    ps: 这题来说的话，其实是可以用python3来莽过的，因py的大数范围很大，可以直接只对结果进行返回...

```cpp
class Solution {
public:
    const int mod = 1e9+7;
    int cuttingRope(int n) {
        if ( n<=3 ) return max(0,n-1); 
        if ( n%3==0 )
            return solve(n/3, 3);
        else if (n%3==1)
            return (solve((n/3)-1, 3) * 4)%mod;
        return (solve((n/3),3)*2)%mod;
    }
    
    long solve(int times, int v){
        long res = 1;
        while(times--){
            res*=v;
            res%=mod;
        }
        return res;
    }
};
```
